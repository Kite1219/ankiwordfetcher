<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dictionary Word Lookup</title>
  <style>
    :root {
      --bg: #0a0a0b;
      --surface: #141416;
      --surface-hover: #1c1c1f;
      --text: #e8e8ea;
      --text-dim: #8a8a8f;
      --accent: #10a37f;
      --accent-hover: #12b88e;
      --border: #2a2a2e;
      --error: #ef4444;
      --radius: 10px;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'SF Pro Text', -apple-system, system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.5;
      min-height: 100vh;
    }

    .app {
      max-width: 900px;
      margin: 0 auto;
      padding: 40px 24px 80px;
    }

    /* Header - Minimal */
    header {
      margin-bottom: 32px;
    }

    header h1 {
      font-size: 1.5rem;
      font-weight: 600;
      letter-spacing: -0.02em;
    }

    /* Word Input Container */
    .input-section {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px;
      margin-bottom: 20px;
    }

    .input-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .input-header h2 {
      font-size: 0.85rem;
      font-weight: 500;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .input-header-right {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .word-count {
      font-size: 0.8rem;
      color: var(--text-dim);
      background: var(--surface-hover);
      padding: 4px 10px;
      border-radius: 12px;
    }

    .btn-icon {
      background: none;
      border: 1px solid var(--border);
      color: var(--text-dim);
      width: 32px;
      height: 32px;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      font-size: 0.9rem;
    }

    .btn-icon:hover {
      background: var(--surface-hover);
      border-color: var(--accent);
      color: var(--text);
    }

    .btn-icon.active {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    /* Tag-based Word Input */
    .word-input-area {
      min-height: 280px;
      max-height: 450px;
      overflow-y: auto;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-content: flex-start;
      cursor: text;
      transition: border-color 0.15s;
    }

    .word-input-area:focus-within {
      border-color: var(--accent);
    }

    /* Word Tags */
    .word-tag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: var(--surface-hover);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px 10px;
      font-size: 0.95rem;
      transition: all 0.15s;
      height: fit-content;
    }

    .word-tag:hover {
      border-color: var(--accent);
    }

    .word-tag.success {
      border-color: var(--accent);
      background: rgba(16, 163, 127, 0.1);
    }

    .word-tag.failed {
      border-color: var(--error);
      background: rgba(239, 68, 68, 0.1);
    }

    .word-tag-status {
      font-size: 0.85rem;
      line-height: 1;
    }

    .word-tag-status.success { color: var(--accent); }
    .word-tag-status.failed { color: var(--error); }

    .word-tag-text {
      color: var(--accent);
      cursor: pointer;
      text-decoration: none;
      font-weight: 500;
    }

    .word-tag-text:hover {
      text-decoration: underline;
    }

    .word-tag.failed .word-tag-text {
      color: var(--error);
    }

    .word-tag-hint {
      font-size: 0.75rem;
      color: var(--text-dim);
      font-style: italic;
    }

    .word-tag-remove {
      background: none;
      border: none;
      color: var(--text-dim);
      cursor: pointer;
      font-size: 1.1rem;
      line-height: 1;
      padding: 0 2px;
      opacity: 0.6;
      transition: all 0.15s;
    }

    .word-tag-remove:hover {
      color: var(--error);
      opacity: 1;
    }

    /* Text View Mode */
    .text-view-area {
      display: none;
      width: 100%;
      min-height: 280px;
      max-height: 450px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
      color: var(--text);
      font-size: 0.95rem;
      line-height: 1.8;
      resize: none;
      outline: none;
    }

    .text-view-area:focus {
      border-color: var(--accent);
    }

    .word-input-area.hidden { display: none; }
    .text-view-area.visible { display: block; }

    /* Inline Text Input */
    .word-type-input {
      flex: 1;
      min-width: 150px;
      background: none;
      border: none;
      color: var(--text);
      font-size: 0.95rem;
      outline: none;
      padding: 8px 4px;
    }

    .word-type-input::placeholder {
      color: var(--text-dim);
      opacity: 0.5;
    }

    /* Help text */
    .input-help {
      display: flex;
      gap: 16px;
      margin-top: 12px;
      font-size: 0.8rem;
      color: var(--text-dim);
    }

    .input-help code {
      background: var(--surface-hover);
      padding: 2px 6px;
      border-radius: 4px;
      font-family: 'SF Mono', monospace;
    }

    /* Controls Row */
    .controls-row {
      display: flex;
      gap: 16px;
      align-items: center;
      flex-wrap: wrap;
    }

    /* Delay Slider - Compact */
    .delay-control {
      display: flex;
      align-items: center;
      gap: 12px;
      flex: 1;
      min-width: 200px;
    }

    .delay-label {
      font-size: 0.85rem;
      color: var(--text-dim);
      white-space: nowrap;
    }

    .delay-slider {
      flex: 1;
      -webkit-appearance: none;
      height: 4px;
      background: var(--border);
      border-radius: 2px;
      outline: none;
    }

    .delay-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: var(--accent);
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.15s;
    }

    .delay-slider::-webkit-slider-thumb:hover {
      transform: scale(1.15);
    }

    .delay-value {
      font-size: 0.85rem;
      color: var(--text);
      min-width: 55px;
      text-align: right;
    }

    /* Primary Button */
    .btn-run {
      background: var(--accent);
      color: white;
      border: none;
      padding: 12px 28px;
      border-radius: var(--radius);
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s;
    }

    .btn-run:hover {
      background: var(--accent-hover);
    }

    .btn-run:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Clear All Button */
    .btn-clear-all {
      background: none;
      border: 1px solid var(--border);
      color: var(--text-dim);
      padding: 12px 20px;
      border-radius: var(--radius);
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.15s;
    }

    .btn-clear-all:hover {
      border-color: var(--error);
      color: var(--error);
    }

    /* Progress */
    .progress-wrap {
      margin: 24px 0;
      display: none;
    }

    .progress-wrap.active { display: block; }

    .progress-bar-track {
      height: 4px;
      background: var(--border);
      border-radius: 2px;
      overflow: hidden;
    }

    .progress-bar-fill {
      height: 100%;
      background: var(--accent);
      width: 0;
      transition: width 0.2s;
    }

    .progress-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      margin-top: 10px;
    }

    .progress-status {
      font-size: 0.85rem;
      color: var(--text-dim);
    }

    .btn-stop {
      background: var(--error);
      color: white;
      border: none;
      padding: 6px 16px;
      border-radius: 6px;
      font-size: 0.85rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
    }

    .btn-stop:hover {
      background: #dc2626;
    }

    /* Results Grid */
    .results {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      margin-top: 24px;
    }

    @media (max-width: 700px) {
      .results { grid-template-columns: 1fr; }
    }

    .result-panel {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
    }

    .result-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 14px 16px;
      border-bottom: 1px solid var(--border);
    }

    .result-title {
      font-size: 0.85rem;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .result-title .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    .result-title .dot.green { background: var(--accent); }
    .result-title .dot.red { background: var(--error); }

    .result-actions {
      display: flex;
      gap: 8px;
    }

    .btn-small {
      background: none;
      border: none;
      color: var(--text-dim);
      font-size: 0.8rem;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
      transition: all 0.15s;
    }

    .btn-small:hover {
      background: var(--surface-hover);
      color: var(--text);
    }

    /* Dropdown */
    .dropdown {
      position: relative;
      display: inline-block;
    }

    .dropdown-menu {
      display: none;
      position: absolute;
      right: 0;
      top: 100%;
      margin-top: 4px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 6px;
      min-width: 180px;
      z-index: 100;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    .dropdown-menu.open {
      display: block;
    }

    .dropdown-item {
      display: block;
      width: 100%;
      padding: 10px 14px;
      background: none;
      border: none;
      color: var(--text);
      font-size: 0.85rem;
      text-align: left;
      cursor: pointer;
      transition: background 0.15s;
    }

    .dropdown-item:first-child {
      border-radius: 6px 6px 0 0;
    }

    .dropdown-item:last-child {
      border-radius: 0 0 6px 6px;
    }

    .dropdown-item:hover {
      background: var(--surface-hover);
    }

    .result-list {
      max-height: 280px;
      overflow-y: auto;
    }

    .result-item {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px;
    }

    .result-item:last-child { border-bottom: none; }

    .result-word {
      color: var(--accent);
      text-decoration: none;
      font-weight: 500;
      font-size: 0.95rem;
    }

    .result-word:hover { text-decoration: underline; }

    .result-meta {
      font-size: 0.8rem;
      color: var(--text-dim);
      margin-top: 2px;
    }

    .result-def {
      font-size: 0.85rem;
      color: var(--text);
      margin-top: 4px;
      opacity: 0.8;
    }

    .result-remove {
      background: none;
      border: none;
      color: var(--text-dim);
      cursor: pointer;
      font-size: 1rem;
      opacity: 0.5;
      transition: all 0.15s;
      flex-shrink: 0;
    }

    .result-remove:hover {
      color: var(--error);
      opacity: 1;
    }

    .empty-state {
      padding: 32px 16px;
      text-align: center;
      color: var(--text-dim);
      font-size: 0.9rem;
    }

    /* Scrollbar */
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--text-dim); }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Dictionary Word Lookup</h1>
    </header>

    <div class="input-section">
      <div class="input-header">
        <h2>Words</h2>
        <div class="input-header-right">
          <span class="word-count" id="word-count">0 words</span>
          <button class="btn-icon" id="btn-copy" title="Copy all words">ðŸ“‹</button>
          <button class="btn-icon" id="btn-text-view" title="Toggle text view for easy copy/paste">Â¶</button>
        </div>
      </div>

      <div class="word-input-area" id="word-input-area">
        <input type="text" class="word-type-input" id="word-type-input" 
               placeholder="Type a word and press Enter or comma..." />
      </div>
      <textarea class="text-view-area" id="text-view-area" placeholder="Paste words here (one per line or comma-separated)..."></textarea>

      <div class="input-help">
        <span>Hints: <code>(n)</code> <code>(v)</code> <code>(adj)</code> <code>(adv)</code></span>
        <span>Click word â†’ Oxford | âœ“ found | âœ— not found</span>
      </div>
    </div>

    <div class="controls-row">
      <div class="delay-control">
        <span class="delay-label">Delay</span>
        <input type="range" class="delay-slider" id="delay" min="100" max="2000" step="50" value="400" />
        <span class="delay-value" id="delayVal">400ms</span>
      </div>
      <button class="btn-clear-all" id="reset-status" title="Reset all to pending for re-lookup">Reset â†»</button>
      <button class="btn-clear-all" id="clear-all">Clear All</button>
      <button class="btn-run" id="run">Lookup & Download</button>
    </div>

    <div class="progress-wrap" id="progress-wrap">
      <div class="progress-bar-track">
        <div class="progress-bar-fill" id="bar"></div>
      </div>
      <div class="progress-row">
        <div class="progress-status" id="status"></div>
        <button class="btn-stop" id="btn-stop">Stop</button>
      </div>
    </div>

    <div class="results">
      <div class="result-panel">
        <div class="result-header">
          <div class="result-title">
            <span class="dot green"></span>
            Found <span id="success-count">(0)</span>
          </div>
          <div class="result-actions">
            <button class="btn-small" id="clear-success">Clear</button>
          </div>
        </div>
        <div class="result-list" id="success-list">
          <div class="empty-state">No words looked up yet</div>
        </div>
      </div>

      <div class="result-panel">
        <div class="result-header">
          <div class="result-title">
            <span class="dot red"></span>
            Not Found
          </div>
          <div class="result-actions">
            <div class="dropdown" id="retry-dropdown">
              <button class="btn-small" id="retry-toggle">Retry â–¾</button>
              <div class="dropdown-menu" id="retry-menu">
                <button class="dropdown-item" data-mode="only">Retry â†’ TSV (retry only)</button>
                <button class="dropdown-item" data-mode="full">Retry â†’ TSV (full list)</button>
              </div>
            </div>
            <button class="btn-small" id="clear-fails">Clear</button>
          </div>
        </div>
        <div class="result-list" id="fail-list">
          <div class="empty-state">All clear!</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Hidden textarea for compatibility with core logic -->
  <textarea id="input" style="display:none;"></textarea>

  <script>
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€ WORD TAGS SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const wordInputArea = document.getElementById('word-input-area');
    const wordTypeInput = document.getElementById('word-type-input');
    const textViewArea = document.getElementById('text-view-area');
    const wordCountEl = document.getElementById('word-count');
    const btnCopy = document.getElementById('btn-copy');
    const btnTextView = document.getElementById('btn-text-view');
    let wordTags = []; // { base, hint, status: 'pending' | 'success' | 'failed' }
    let isTextView = false;

    function getOxfordUrl(word) {
      return `https://www.oxfordlearnersdictionaries.com/search/english/?q=${encodeURIComponent(word)}`;
    }

    function parseLine(l) {
      const m = l.match(/^(.*?)(?:\s*\((n|v|adj|adv)\))?$/i);
      return { base: m[1].trim(), hint: m[2]?.toLowerCase() || '', status: 'pending' };
    }

    function addWordTag(text, status = 'pending') {
      const trimmed = text.trim();
      if (!trimmed) return;
      
      const parsed = parseLine(trimmed);
      parsed.status = status;
      
      // Check for duplicate - update status if exists
      const existingIdx = wordTags.findIndex(t => t.base.toLowerCase() === parsed.base.toLowerCase());
      if (existingIdx >= 0) {
        wordTags[existingIdx].status = status;
      } else {
        wordTags.push(parsed);
      }
      
      renderTags();
      updateWordCount();
      syncHiddenTextarea();
    }

    function removeWordTag(index) {
      wordTags.splice(index, 1);
      renderTags();
      updateWordCount();
      syncHiddenTextarea();
    }

    function updateTagStatus(base, status) {
      const tag = wordTags.find(t => t.base.toLowerCase() === base.toLowerCase());
      if (tag) {
        tag.status = status;
        renderTags();
      }
    }

    function renderTags() {
      // Remove existing tags
      wordInputArea.querySelectorAll('.word-tag').forEach(el => el.remove());
      
      // Add tags before the input
      wordTags.forEach((tag, i) => {
        const tagEl = document.createElement('div');
        tagEl.className = `word-tag ${tag.status !== 'pending' ? tag.status : ''}`;
        
        let statusIcon = '';
        if (tag.status === 'success') statusIcon = '<span class="word-tag-status success">âœ“</span>';
        else if (tag.status === 'failed') statusIcon = '<span class="word-tag-status failed">âœ—</span>';
        
        tagEl.innerHTML = `
          ${statusIcon}
          <a href="${getOxfordUrl(tag.base)}" target="_blank" class="word-tag-text">${tag.base}</a>
          ${tag.hint ? `<span class="word-tag-hint">(${tag.hint})</span>` : ''}
          <button class="word-tag-remove" data-index="${i}">Ã—</button>
        `;
        wordInputArea.insertBefore(tagEl, wordTypeInput);
      });
      
      // Sync text view
      syncTextView();
    }

    function updateWordCount() {
      const successCount = wordTags.filter(t => t.status === 'success').length;
      const failedCount = wordTags.filter(t => t.status === 'failed').length;
      let text = `${wordTags.length} word${wordTags.length !== 1 ? 's' : ''}`;
      if (successCount || failedCount) {
        text += ` (âœ“${successCount} âœ—${failedCount})`;
      }
      wordCountEl.textContent = text;
    }

    function syncHiddenTextarea() {
      const lines = wordTags.map(t => t.hint ? `${t.base} (${t.hint})` : t.base);
      document.getElementById('input').value = lines.join('\n');
    }

    function syncTextView() {
      const lines = wordTags.map(t => t.hint ? `${t.base} (${t.hint})` : t.base);
      textViewArea.value = lines.join('\n');
    }

    function toggleTextView() {
      isTextView = !isTextView;
      wordInputArea.classList.toggle('hidden', isTextView);
      textViewArea.classList.toggle('visible', isTextView);
      btnTextView.classList.toggle('active', isTextView);
      
      if (isTextView) {
        syncTextView();
        textViewArea.focus();
      } else {
        // Parse text view back to tags
        const lines = textViewArea.value.split(/[\n]+/).map(s => s.trim()).filter(Boolean);
        const existingStatuses = {};
        wordTags.forEach(t => existingStatuses[t.base.toLowerCase()] = t.status);
        
        wordTags = [];
        lines.forEach(line => {
          const parsed = parseLine(line);
          // Preserve existing status
          parsed.status = existingStatuses[parsed.base.toLowerCase()] || 'pending';
          wordTags.push(parsed);
        });
        renderTags();
        updateWordCount();
        syncHiddenTextarea();
      }
    }

    function copyAllWords() {
      const lines = wordTags.map(t => t.base);
      navigator.clipboard.writeText(lines.join('\n')).then(() => {
        btnCopy.textContent = 'âœ“';
        setTimeout(() => btnCopy.textContent = 'ðŸ“‹', 1500);
      });
    }

    // Toggle text view
    btnTextView.addEventListener('click', toggleTextView);

    // Copy all words
    btnCopy.addEventListener('click', copyAllWords);

    // Click area to focus input
    wordInputArea.addEventListener('click', (e) => {
      if (e.target === wordInputArea) wordTypeInput.focus();
    });

    // Handle input
    wordTypeInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ',') {
        e.preventDefault();
        addWordTag(wordTypeInput.value);
        wordTypeInput.value = '';
      } else if (e.key === 'Backspace' && !wordTypeInput.value && wordTags.length) {
        removeWordTag(wordTags.length - 1);
      }
    });

    // Allow pasting multiple words
    wordTypeInput.addEventListener('paste', (e) => {
      e.preventDefault();
      const text = e.clipboardData.getData('text');
      const lines = text.split(/[\n,]+/).map(s => s.trim()).filter(Boolean);
      lines.forEach(line => addWordTag(line));
      wordTypeInput.value = '';
    });

    // Remove tag button
    wordInputArea.addEventListener('click', (e) => {
      if (e.target.classList.contains('word-tag-remove')) {
        removeWordTag(parseInt(e.target.dataset.index));
      }
    });

    // Clear all words
    document.getElementById('clear-all').addEventListener('click', () => {
      wordTags = [];
      renderTags();
      updateWordCount();
      syncHiddenTextarea();
    });

    // Reset all statuses to pending
    document.getElementById('reset-status').addEventListener('click', () => {
      wordTags.forEach(t => t.status = 'pending');
      renderTags();
      updateWordCount();
    });

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€ SLIDER â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const slider = document.getElementById('delay');
    const delayVal = document.getElementById('delayVal');
    
    function updateSlider() {
      delayVal.textContent = slider.value + 'ms';
    }
    slider.addEventListener('input', updateSlider);
    updateSlider();

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€ LOCAL STORAGE â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let successfulLookups = [], notFoundWords = [];
    
    function loadStored() {
      try {
        successfulLookups = JSON.parse(localStorage.getItem('dictionaryLookups') || '[]');
      } catch { successfulLookups = []; }
      try {
        notFoundWords = JSON.parse(localStorage.getItem('dictionaryNotFound') || '[]');
      } catch { notFoundWords = []; }
    }
    
    function saveSuccess() {
      localStorage.setItem('dictionaryLookups', JSON.stringify(successfulLookups));
    }
    
    function saveFails() {
      localStorage.setItem('dictionaryNotFound', JSON.stringify(notFoundWords));
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€ UI UPDATES â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const successList = document.getElementById('success-list');
    const successCount = document.getElementById('success-count');
    const failList = document.getElementById('fail-list');

    function updateSuccessList() {
      successCount.textContent = `(${successfulLookups.length})`;
      if (!successfulLookups.length) {
        successList.innerHTML = '<div class="empty-state">No words looked up yet</div>';
        return;
      }
      successList.innerHTML = successfulLookups.map(it => `
        <div class="result-item">
          <div>
            <a href="${it.url}" target="_blank" class="result-word">${it.word}</a>
            <div class="result-meta">${it.pos || ''}</div>
            <div class="result-def">${it.firstDef}</div>
          </div>
        </div>
      `).join('');
    }

    function updateFailList() {
      if (!notFoundWords.length) {
        failList.innerHTML = '<div class="empty-state">All clear!</div>';
        return;
      }
      failList.innerHTML = notFoundWords.map(w => `
        <div class="result-item">
          <a href="${getOxfordUrl(w)}" target="_blank" class="result-word">${w}</a>
          <button class="result-remove" data-word="${w}">Ã—</button>
        </div>
      `).join('');
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€ INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€
    loadStored();
    updateSuccessList();
    updateFailList();

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€ REMOVE FAIL â”€â”€â”€â”€â”€â”€â”€â”€â”€
    failList.addEventListener('click', e => {
      if (e.target.classList.contains('result-remove')) {
        notFoundWords = notFoundWords.filter(x => x !== e.target.dataset.word);
        saveFails();
        updateFailList();
      }
    });

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€ CLEAR BUTTONS â”€â”€â”€â”€â”€â”€â”€â”€â”€
    document.getElementById('clear-success').onclick = () => {
      successfulLookups = [];
      saveSuccess();
      updateSuccessList();
    };
    
    document.getElementById('clear-fails').onclick = () => {
      notFoundWords = [];
      saveFails();
      updateFailList();
    };

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€ RETRY FAILS DROPDOWN â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const retryToggle = document.getElementById('retry-toggle');
    const retryMenu = document.getElementById('retry-menu');
    let retryMode = 'only'; // 'only' or 'full'

    retryToggle.onclick = (e) => {
      e.stopPropagation();
      if (!notFoundWords.length) {
        alert('No failed words to retry');
        return;
      }
      retryMenu.classList.toggle('open');
    };

    // Close dropdown when clicking outside
    document.addEventListener('click', () => {
      retryMenu.classList.remove('open');
    });

    retryMenu.onclick = (e) => {
      if (e.target.classList.contains('dropdown-item')) {
        retryMode = e.target.dataset.mode;
        retryMenu.classList.remove('open');
        startRetry();
      }
    };

    function startRetry() {
      if (!notFoundWords.length) return;
      
      // Reset failed words to pending status for retry
      notFoundWords.forEach(w => {
        const tag = wordTags.find(t => t.base.toLowerCase() === w.toLowerCase());
        if (tag) {
          tag.status = 'pending';
        } else {
          addWordTag(w, 'pending');
        }
      });
      renderTags();
      updateWordCount();
      notFoundWords = [];
      saveFails();
      updateFailList();
      
      // Trigger lookup with retry mode
      runLookup(retryMode === 'full');
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€ HELPERS & SCRAPER â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const proxy = u => `https://api.allorigins.win/raw?url=${encodeURIComponent(u)}`;
    const sleep = ms => new Promise(r => setTimeout(r, ms));
    const qs = (s, c = document) => c.querySelector(s);
    const qsa = (s, c = document) => [...c.querySelectorAll(s)];
    const txt = e => e ? e.textContent.trim() : '';
    const bullet = '\u2022 ';
    const posMap = { n: 'noun', v: 'verb', adj: 'adjective', adv: 'adverb' };
    const singular = w => w.replace(/ies$/, 'y').replace(/s$/, '');

    function scrape(doc) {
      const head = txt(qs('.webtop-g h2 .hw', doc)
        || qs('.webtop-g h2', doc)
        || qs('#entryContent h1', doc)
        || qs('h1', doc));
      const extras = [];
      const header = qs('.webtop-g', doc) || qs('.webtop', doc);
      if (header) {
        const text = header.innerText.replace(/\s+/g, ' ');
        (text.match(/\([^)]*\)/g) || []).forEach(t => {
          if (!/^\(\/.*\/\)$/.test(t) && !/^\(\d/.test(t))
            extras.push(t);
        });
      }
      qsa('#entryContent > p', doc).forEach(p => {
        const t = txt(p);
        if (/^\(.*\)$/.test(t)) extras.push(t);
      });
      const extra = [...new Set(extras)].join('<br>');
      const senses = [];
      qsa('#entryContent li.sense', doc).forEach((li, i) => {
        const defEl = qs('span.def', li);
        if (!defEl) return;
        let html = '';
        const lbl = txt(qs('span.registerlabel, span.grammar, span.label, span.labels', li));
        if (lbl) html += `<i>${lbl}</i><br>`;
        html += `${i+1}. ${txt(defEl)}`;
        const syn = txt(qs('span.syn', li));
        if (syn) html += `<br><b>Synonym:</b> ${syn}`;
        const exs = qsa('span.x', li).map(x => txt(x));
        if (exs.length) html += '<br>' + exs.map(e => bullet + e).join('<br>');
        senses.push(html);
      });
      if (!senses.length) return null;
      return {
        head,
        extra,
        senses,
        pos: txt(qs('span.pos', doc)),
        phon: txt(qs('span.phon', doc))
      };
    }

    async function fetchPage(slug) {
      const pageUrl = `https://www.oxfordlearnersdictionaries.com/definition/english/${slug}`;
      try {
        const h = await (await fetch(proxy(pageUrl))).text();
        const data = scrape(new DOMParser().parseFromString(h, 'text/html'));
        if (data) return { ...data, url: pageUrl };
      } catch {}
      return null;
    }

    async function fetchSearch(w) {
      try {
        const searchUrl = `https://www.oxfordlearnersdictionaries.com/search/english/?q=${encodeURIComponent(w)}`;
        const h = await (await fetch(proxy(searchUrl))).text();
        const doc = new DOMParser().parseFromString(h, 'text/html');
        let data = scrape(doc);
        if (data) return { ...data, url: searchUrl };
        const link = qs('.result-list a', doc)?.href
          || qs('a[href*="/definition/english/"]', doc)?.href;
        if (!link) return null;
        const m = link.match(/\/definition\/english\/([^\/?#]+)/);
        if (!m) return null;
        return await fetchPage(m[1]);
      } catch {
        return null;
      }
    }

    async function fetchOxford(w, h) {
      if (h) {
        for (let i = 1; i <= 8; i++) {
          const d = await fetchPage(`${w}_${i}`);
          if (d && d.pos.toLowerCase().startsWith(posMap[h])) return d;
        }
      }
      return (await fetchPage(w)) || (await fetchSearch(w));
    }

    async function lookup(o) {
      let d = await fetchOxford(o.base, o.hint);
      if (d) return { word: d.head || o.base, ...d };
      if (o.base.endsWith('s')) {
        d = await fetchOxford(singular(o.base), o.hint);
        if (d) return { word: d.head, ...d };
      }
      return { word: o.base, senses: ['[Not found]'], pos: '', phon: '', extra: '', failed: true };
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€ MAIN RUN BUTTON â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const runBtn = document.getElementById('run'),
          btnStop = document.getElementById('btn-stop'),
          progressWrap = document.getElementById('progress-wrap'),
          bar = document.getElementById('bar'),
          status = document.getElementById('status');
    
    let stopRequested = false;

    btnStop.onclick = () => {
      stopRequested = true;
      btnStop.disabled = true;
      btnStop.textContent = 'Stopping...';
    };

    // Main run button calls with includeAll = false
    runBtn.onclick = () => runLookup(false);

    async function runLookup(includeAllPrevious = false) {
      // Only lookup words that are pending (not already looked up)
      const pendingTags = wordTags.filter(t => t.status === 'pending');
      if (!pendingTags.length) {
        if (wordTags.length) {
          return alert('All words already looked up. Clear or add new words.');
        }
        return alert('Add some words first');
      }

      stopRequested = false;
      btnStop.disabled = false;
      btnStop.textContent = 'Stop';
      runBtn.disabled = true;
      progressWrap.classList.add('active');
      notFoundWords = [];
      let rows = [];
      const delay = Math.max(100, +slider.value);

      for (let i = 0; i < pendingTags.length; i++) {
        if (stopRequested) {
          status.textContent = `Stopped at ${i}/${pendingTags.length}`;
          break;
        }

        const tag = pendingTags[i];
        status.textContent = `Looking up "${tag.base}" (${i+1}/${pendingTags.length})`;
        bar.style.width = `${(i+1)/pendingTags.length*100}%`;
        
        const d = await lookup(tag);

        if (d.failed) {
          notFoundWords.push(tag.base);
          updateTagStatus(tag.base, 'failed');
        } else {
          updateTagStatus(tag.base, 'success');
          
          let html = '';
          if (d.extra) html += `<i>${d.extra}</i><br>`;
          html += d.senses.join('<br><br>');
          const tsvRow = `${d.word}\t${html.replace(/\t/g,' ')}\t${d.pos}\t${d.phon}`;
          rows.push(tsvRow);

          const firstDef = d.senses[0]
            .replace(/<[^>]*>/g, '')
            .replace(/^\d+\.\s*/, '')
            .split('<br>')[0];
          const idx = successfulLookups.findIndex(x => x.word === d.word);
          if (idx >= 0) successfulLookups.splice(idx, 1);
          successfulLookups.unshift({
            word: d.word,
            pos: d.pos,
            firstDef,
            url: d.url,
            tsvRow: tsvRow // Store TSV row for full export
          });
          if (successfulLookups.length > 100) {
            successfulLookups = successfulLookups.slice(0, 100);
          }
        }

        await sleep(delay);
      }

      // Save & refresh
      saveSuccess();
      saveFails();
      updateSuccessList();
      updateFailList();
      updateWordCount();

      // Download TSV
      if (rows.length || includeAllPrevious) {
        let finalRows = rows;
        
        if (includeAllPrevious) {
          // Get all previous successful lookups that have tsvRow and aren't in current rows
          const currentWords = new Set(rows.map(r => r.split('\t')[0].toLowerCase()));
          const previousRows = successfulLookups
            .filter(s => s.tsvRow && !currentWords.has(s.word.toLowerCase()))
            .map(s => s.tsvRow);
          finalRows = [...rows, ...previousRows];
        }

        if (finalRows.length) {
          const blob = new Blob([finalRows.join('\n')], { type: 'text/tab-separated-values' });
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = includeAllPrevious ? 'dictionary_words_full.tsv' : 'dictionary_words.tsv';
          a.click();
        }
      }

      if (!stopRequested) {
        const mode = includeAllPrevious ? ' (full list)' : '';
        status.textContent = `Done! ${rows.length} found, ${notFoundWords.length} missing${mode}`;
      }
      runBtn.disabled = false;
      
      setTimeout(() => {
        bar.style.width = '0';
        progressWrap.classList.remove('active');
      }, 3000);
    }
  </script>
</body>
</html>
